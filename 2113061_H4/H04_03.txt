#include<iostream>
using namespace std;

//无向边类
class line {
public:
	int adjvex;
	line* nextline;
};

class node {
public:
	line* firstline;
};

class Graph {
public:
	int vexnum, arcnum;
	bool* visited;
	int* color;
	node* nodes;

	Graph(int vex, int arc);
	~Graph();
	void in_line(int x, int y);
	int firstNeighbor(int x);
	int nextNeighbor(int x, int y);
	bool dfs(int x, int c);//dfs算法改为染色法寻找奇环,c表示颜色，1为浅色，2为深色
};

Graph::Graph(int vex, int arc) {
	vexnum = vex;
	arcnum = arc;
	nodes = new node[vex+1];
	visited = new bool[vex+1];
	color = new int[vex+1];
	for (int i = 0; i < vex+1; i++) {
		visited[i] = false;
		nodes[i].firstline = nullptr;
		color[i] = -1;
	}
}

Graph::~Graph() {
	delete[]visited;
	visited = nullptr;
	delete[] color;
	color = nullptr;
	for (int i = 0; i < vexnum; i++) {
		delete nodes[i].firstline;
	}
	delete[] nodes;
	nodes = nullptr;
}

void Graph::in_line(int x, int y) {
	if (nodes[x].firstline == nullptr) {
		line* line1 = new line;
		line1->adjvex = y;
		line1->nextline = nullptr;
		nodes[x].firstline = line1;
	}

	else if (nodes[x].firstline != nullptr) {
		line* line2 = nodes[x].firstline;
		while (line2->nextline) {
			line2 = line2->nextline;
		}
		line* line1 = new line;
		line1->adjvex = y;
		line1->nextline = nullptr;
		line2->nextline = line1;
	}
	else if (nodes[y].firstline == nullptr) {
		line* line1 = new line;
		line1->adjvex = x;
		line1->nextline = nullptr;
		nodes[y].firstline = line1;
	}

	else if (nodes[y].firstline != nullptr) {
		line* line2 = nodes[y].firstline;
		while (line2->nextline) {
			line2 = line2->nextline;
		}
		line* line1 = new line;
		line1->adjvex = x;
		line1->nextline = nullptr;
		line2->nextline = line1;
	}
}

int Graph::firstNeighbor(int x) {
	if (nodes[x].firstline == nullptr)
		return -1;
	return nodes[x].firstline->adjvex;
}

int Graph::nextNeighbor(int x, int y) {
	if (nodes[x].firstline == nullptr)
		return -1;
	line* line1 = nodes[x].firstline;
	while (!(line1->adjvex == y)) {
		line1 = line1->nextline;
	}
	if (line1->nextline == nullptr)
		return -1;
	return line1->nextline->adjvex;
}

//染色法判断是否有奇环，return 1表示有奇数环，不是二分图
bool Graph::dfs(int x, int c) {
	color[x] = c;
	for (int w = firstNeighbor(x); w >= 0; w = nextNeighbor(x, w)) {
		if (!color[w]) {
			if (dfs(w, 3 - c))
				return 1;
		}
		else if (color[w] == c)
			return 1;
	}
	return 0;
}

int main() {
	int vex, arc;
	cin >> vex >> arc;
	Graph g(vex, arc);

	for (int i = 0; i < g.arcnum; i++) {
		int x, y;
		cin >> x >> y;
		g.in_line(x, y);
	}

	bool flag = 0;
	for (int i = 0; i < g.vexnum; i++) {
		if (!g.color[i]) {
			if (g.dfs(i, 1)) {
				flag = 1;
				break;
			}
		}
	}


	cout << "if the graph is bipartite graph:" << endl;
	if (flag == 1)
		cout << "No";
	else
		cout << "Yes";
	return 0;
}