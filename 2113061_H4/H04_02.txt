#include<iostream>
#include<queue>
using namespace std;

queue<int> Q;//队列帮助进行广度优先搜索

//无向边类
class line {
public:
	int adjvex;//有向边指向的结点
	line* nextline;//起点的下一条边
};

//结点类
class node {
public:
	//int data;//结点数据
	line* firstline;//该点的第一条边
};

//图类
class Graph {
public:
	int vexnum, arcnum, head;
	bool *visited;
	node* nodes ;

	Graph(int vex, int arc, int head);
	~Graph();
	void in_line(int x, int y);//输入边
	int firstNeighbor(int x);//返回结点第一个相邻点
	int nextNeighbor(int x, int y);//返回结点下一个相邻点
	void BFS(int x);//从节点x开始进行广度优先搜索
	void DFS(int x);//从节点x开始进行深度优先搜索
	void reset();//重置visited
};

Graph::Graph(int vex, int arc, int head) {
	vexnum = vex;
	arcnum = arc;
	this->head = head;
	nodes = new node[vex];
	visited = new bool[vex];
	for (int i = 0; i < vex; i++) {
		visited[i] = false;//标记是否访问
		nodes[i].firstline = nullptr;//各结点边置零
	}

}

void Graph::reset() {
	for (int i = 0; i < vexnum; i++) {
		visited[i] = false;
	}
}

Graph::~Graph() {
	delete[]visited;
	visited = nullptr;
	for (int i = 0; i < vexnum; i++) {
	 delete nodes[i].firstline;
	}
	delete[]nodes;
	nodes = nullptr;
}
void Graph::in_line(int x, int y) {
	if (nodes[x].firstline == nullptr) {
		line* line1 = new line;
		line1->adjvex = y;
		line1->nextline = nullptr;
		nodes[x].firstline = line1;
	}

	else if (nodes[x].firstline != nullptr) {
		line* line2 = nodes[x].firstline;
		while (line2->nextline) {
			line2 = line2->nextline;
		}
		line* line1 = new line;
		line1->adjvex = y;
		line1->nextline = nullptr;
		line2->nextline = line1;
	}

	if (nodes[y].firstline == nullptr) {
		line* line1 = new line;
		line1->adjvex = x;
		line1->nextline = nullptr;
		nodes[y].firstline = line1;
	}

	else if (nodes[y].firstline != nullptr) {
		line* line2 = nodes[y].firstline;
		while (line2->nextline) {
			line2 = line2->nextline;
		}
		line* line1 = new line;
		line1->adjvex = x;
		line1->nextline = nullptr;
		line2->nextline = line1;
	}
}

int Graph::firstNeighbor(int x) {
	if (nodes[x].firstline == nullptr)
		return -1;
	return nodes[x].firstline->adjvex;
}

int Graph::nextNeighbor(int x, int y) {
	if (nodes[x].firstline == nullptr)
		return -1;
	line* line1 = nodes[x].firstline;
	while (!(line1->adjvex == y)) {
		line1 = line1->nextline;
	}
	if (line1->nextline == nullptr)
		return -1;
	return line1->nextline->adjvex;
}

void Graph::BFS(int x) {
	visited[x] = true;//打上标记，表示已经访问
	Q.push(x);
	cout << x << " ";
	while (!empty(Q)) {
		int n = Q.front();
		Q.pop();
		//挨个遍历n所有邻接点
		for (int w = firstNeighbor(n); w >= 0; w = nextNeighbor(n, w))
		{
			if (!visited[w] && w < vexnum) {
				visited[w] = true;
				Q.push(w);
				cout << w << " ";
			}
		}
	}
	cout << endl;


}

void Graph::DFS(int x) {
	visited[x] = true;
	cout << x << " ";

	for (int w = firstNeighbor(x); w >= 0; w = nextNeighbor(x, w)) {
		if (!visited[w]) {
			DFS(w);
		}
	}
}

int main() {

	int _vex, _arc, _head;
	cin >> _vex >> _arc >> _head;
	Graph g(_vex, _arc, _head);

	for (int i = 0; i < g.arcnum; i++) {
		int x, y;
		cin >> x >> y;
		g.in_line(x, y);
	}
	cout << "*********************进行图的广度优先遍历（BFS）*********************" << endl;
	g.reset();
	g.BFS(g.head);

	cout << "*********************进行图的广度优先遍历（DFS）*********************" << endl;
	g.reset();
	g.DFS(g.head);
	return 0;
	
}