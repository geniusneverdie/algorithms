#include<iostream>
#include<queue>
using namespace std;

queue<int> Q;

//无向边
class linenode {
public:
	int adjvertex;//顶点
	//int weight;//边的权值
	linenode* nextline;//下一条边
};

//顶点
class node {
public:
	int data;//顶点数据
	linenode *firstline;//指向第一条边的指针
};


//无向图,邻接表法
class Graph {
public:
	int vexnum;//顶点数量
	int arcnum;//边数量
	int head;//头结点
	bool visited[100];//访问记录
	int layer[100];//各结点层次
	node* nodes;
	Graph(int vex, int arc, int h);
	~Graph() { delete nodes; }
	//void bfs(int head);
	void in_line(int x, int y);//输入边
	void find_layer();//求图中每个结点的层次
	int firstNeighbor(int x);//求结点x的第一个邻接点
	int nextNeighbor(int x, int y);//y为结点x邻接点，求结点x，y以后的下一个邻接点
};

Graph::Graph(int vex, int arc, int h) {
	vexnum = vex;
	arcnum = arc;
	head = h;
	nodes = new node[vex];
	for (int i = 0; i < vex; i++) {
		visited[i] = false;
	}

	for (int i = 0; i < vex; i++) {
		layer[i] = -1;
	}

	for (int i = 0; i < vex; i++) {
		nodes[i].firstline = nullptr;
	}
}

//输入xy为结点的边
void Graph::in_line(int x, int y) {
	if (nodes[x].firstline == nullptr) {
		linenode *line1=new linenode;
		line1->adjvertex = y;
		line1->nextline = nullptr;
		nodes[x].firstline = line1;
	}
	else if (nodes[x].firstline != nullptr) {
		linenode* line2= nodes[x].firstline;
		while (line2->nextline) {
			line2 = line2->nextline;
		}
		linenode* line1=new linenode;
		line1->adjvertex = y;
		line2->nextline = line1;
		line1->nextline = nullptr;
	}

	if (nodes[y].firstline == nullptr) {
		linenode *line1=new linenode;
		line1->adjvertex = x;
		line1->nextline = nullptr;
		nodes[y].firstline = line1;
	}
	else if (nodes[y].firstline != nullptr) {
		linenode* line2= nodes[y].firstline;
		while (line2->nextline) {
			line2 = line2->nextline;
		}
		linenode* line1=new linenode;
		line1->adjvertex = x;
		line2->nextline = line1;
		line1->nextline = nullptr;
	}

}

//返回第一个邻接点
int Graph::firstNeighbor(int x) {
	if (nodes[x].firstline == nullptr)
		return -1;
	node node1 = nodes[x];
	return node1.firstline->adjvertex;
}

//返回y下一个邻接点
int Graph::nextNeighbor(int x, int y) {
	linenode* line1 = nullptr;
	line1 = nodes[x].firstline;
	while (!(y == line1->adjvertex)) {
		line1 = line1->nextline;
	}
	if (line1->nextline == nullptr)
		return -1;
	return line1->nextline->adjvertex;
}

void Graph::find_layer() {
	visited[head] = true;
	layer[head] = 0;
	Q.push(head);

	while (!empty(Q)) {
		int n = Q.front();
		Q.pop();
		for (int w = firstNeighbor(n); w >= 0; w = nextNeighbor(n, w)) {
			if (!visited[w]) {
				visited[w] = true;
				Q.push(w);
				layer[w] = layer[n] + 1;
			}
		}
	}
}

int main() {

	int _vex, _arc, _head;
	cout << "请依次输入结点数、边数、开始结点"<<endl;
	cin >> _vex >> _arc >> _head;

	Graph g(_vex, _arc, _head);
	cout << "依次输入" << g.arcnum << "条边"<<endl;
	for (int i = 0; i < g.arcnum; i++) {
		int x, y;
		cout << "输入第" << i + 1 << "条边"<<endl;
		cin >> x >> y;
		g.in_line(x, y);
	}
	g.find_layer();
	cout << "*************************************************************************************************"<<endl;
	cout << "依次输出各条边层次"<<endl;
	for (int i = 0; i < g.vexnum; i++) {
		cout << g.layer[i] << " ";
	}

	return 0;
}